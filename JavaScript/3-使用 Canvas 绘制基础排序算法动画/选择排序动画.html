<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>使用 canvas 实现选择排序动画</title>
    <style>
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <h1>使用 canvas 实现选择排序动画</h1>
    <h3>
      选择排序的核心思想是通过不断地选择未排序部分中的最小（或最大）元素，然后将其放入已排序部分的末尾，逐步构建有序的列表。
    </h3>
    <canvas id="selectionSortCanvas" width="400" height="200"></canvas>
    <button onclick="startSorting()">开始排序</button>
    <div>
      <h4>
        选择排序是一种简单直观的排序算法，其原理可以用以下通俗易懂的方式描述：
      </h4>
      <ol>
        <li>假设有一组乱序的数字排列在一个列表中。</li>
        <li>
          选择排序会在这个列表中找到最小（或最大）的数字，并把它放在列表的开头（或末尾，取决于排序方向）。
        </li>
        <li>
          接下来，它会从剩余的未排序部分中再次找到最小（或最大）的数字，然后将其放在已排序部分的末尾。
        </li>
        <li>
          这个过程会一直重复，每次在未排序部分中找到最小（或最大）的数字并放到已排序部分的末尾，直到整个列表都被排序完毕。
        </li>
        <li>当所有的数字都被放置在正确的位置后，排序完成。</li>
      </ol>
    </div>

    <script>
      const canvas = document.getElementById("selectionSortCanvas");
      const ctx = canvas.getContext("2d");

      const arr = [6, 5, 3, 1, 8, 7, 2, 4];
      const n = arr.length;

      let i = 0;
      let j = 0;
      let minIndex = 0;

      function drawArray() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const barWidth = canvas.width / n;
        const barHeightUnit = canvas.height / Math.max(...arr);

        for (let k = 0; k < n; k++) {
          const x = k * barWidth;
          const height = arr[k] * barHeightUnit;

          // 绘制矩形
          ctx.fillStyle = k === i || k === j ? "red" : "blue";
          ctx.fillRect(x, canvas.height - height, barWidth - 2, height);

          // 标记数字
          ctx.fillStyle = "white";
          ctx.font = "20px Arial";
          ctx.fillText(
            arr[k],
            x + barWidth / 2 - 6,
            canvas.height - height + 20
          );
        }
      }

      function selectionSortStep() {
        if (i < n - 1) {
          minIndex = i;
          for (let k = i + 1; k < n; k++) {
            if (arr[k] < arr[minIndex]) {
              minIndex = k;
            }
          }

          if (minIndex !== i) {
            const temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
          }

          j = i;
          i++;
        } else {
          // 排序完成
          clearInterval(animationInterval);
        }

        drawArray();
      }

      let animationInterval;

      function startSorting() {
        i = 0;
        j = 0;

        // 设置动画间隔
        animationInterval = setInterval(selectionSortStep, 1000); // 调整动画速度
      }

      drawArray();
    </script>
  </body>
</html>
